<!doctype html>
<html lang="tr">
	<head>
		<!--
========================================
 NoteFlix ‚Äì MVP v5.8.2 Master Build
 Milestone √ñzeti (2025-09-12)
========================================

‚úÖ Entegre edilen altyapƒ±lar:
1. Veri katmanƒ± (IndexedDB + OPFS)
2. Offline-first (save ‚Üí pending, online ‚Üí push)
3. Google Drive entegrasyonu (NoteFlix klas√∂r√º, drive.file scope)
4. ≈ûifreleme & Sƒ±kƒ±≈ütƒ±rma (AES-GCM + fflate)
5. Quota & LRU (storage.estimate + eviction)
6. Chunklama iskeleti (v6.x i√ßin hook)
7. Debug loglama
8. SynchronizeGoogleDrive() ‚Üí pullFromGoogle + pushToGoogle birle≈üik
9. backgroundPreload() ‚Üí arka planda cache doldurma
10. checkQuotaAndEvict() ‚Üí storage kotasƒ± a≈üƒ±lƒ±rsa LRU eviction

‚ö†Ô∏è Hen√ºz yapƒ±lmadƒ± (v5.9+):
- Conflict resolution
- Delta sync
- Ger√ßek chunklama
- Geli≈ümi≈ü LRU eviction
- Drive‚Äôda versiyonlama & alt klas√∂rler
-->
		<meta charset="utf-8" />
		<title>NoteFlix ‚Äì MVP v5.8.2 Master</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="icon" href="data:image/svg+xml,
	
	<svg
		xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
		<text y='.9em' font-size='90'>üìù</text>
	</svg>">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.snow.css">
		<script src="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
		<script src="https://accounts.google.com/gsi/client" async defer></script>
		<script src="https://apis.google.com/js/api.js" async defer></script>
		<meta http-equiv="Permissions-Policy" content="unload=*, popups=*">
		<meta http-equiv="Cross-Origin-Opener-Policy" content="unsafe-none">
		<style>
			body {
				font-family: sans-serif;
				margin: 0;
				background: #111;
				color: #eee;
			}

			header {
				background: #222;
				padding: 10px;
			}

			input,
			button {
				padding: 6px;
				margin: 4px;
			}

			#editor {
				height: 200px;
				background: #fff;
				color: #000;
			}

			.pill {
				padding: 2px 6px;
				border: 1px solid #555;
				border-radius: 6px;
				margin-left: 6px;
				font-size: 12px;
			}

			#status {
				white-space: pre-wrap;
				font-family: monospace;
				font-size: 12px;
				background: #000;
				color: #0f0;
				height: 200px;
				overflow: auto;
				padding: 6px;
			}

			table {
				border-collapse: collapse;
				width: 100%;
			}

			td,
			th {
				border: 1px solid #444;
				padding: 4px;
			}

			/* Overlay arkaplan */
			#historyOverlay {
				display:none;
				position:fixed;
				top:0; left:0; right:0; bottom:0;
				background:rgba(0,0,0,0.6);
				z-index:999;
				backdrop-filter: blur(3px);
			}

			/* Modal kutusu */
			#historyModal {
				position:fixed;
				top:10%;
				left:50%;
				transform:translateX(-50%);
				background:#1e1e1e;
				color:#eee;
				padding:20px;
				border-radius:12px;
				width:600px;
				max-height:70%;
				overflow:auto;
				z-index:1000;
				box-shadow:0 4px 20px rgba(0,0,0,0.4);
				animation: fadeIn 0.3s ease;
			}

			#historyModal h3 {
				margin-top:0;
				font-size:18px;
				border-bottom:1px solid #444;
				padding-bottom:8px;
			}

			#historyModal table {
				width:100%;
				border-collapse:collapse;
				margin:10px 0;
				font-size:14px;
			}

			#historyModal th, #historyModal td {
				border-bottom:1px solid #333;
				padding:8px;
				text-align:left;
			}

			#historyModal tr:hover {
				background:#2a2a2a;
			}

			#historyModal button {
				background:#333;
				border:none;
				color:#eee;
				padding:6px 10px;
				border-radius:6px;
				cursor:pointer;
				font-size:13px;
				margin:2px;
				transition:background 0.2s;
			}

			#historyModal button:hover {
				background:#555;
			}

			#historyModal .closeBtn {
				margin-top:10px;
				float:right;
				background:#c33;
			}

			@keyframes fadeIn {
				from { opacity:0; transform:translate(-50%, -20%); }
				to { opacity:1; transform:translate(-50%, 0); }
			}

		</style>
	</head>
	<body>
		<header>
			<h2>NoteFlix v5.8.2 ‚Äì Master</h2>
			<div>
				<button id="googleConnectBtn">Google'a Baƒülan</button>
				<span id="who" class="pill">Baƒülƒ± deƒüil</span>
			</div>
			<div>
				<button id="syncBtn">Senkronize Et</button>
				<span id="syncState" class="pill">Sync: beklemede</span>
			</div>
			<div>
				<input id="title" type="text" placeholder="Ba≈ülƒ±k">
				<button id="newBtn">Yeni</button>
				<button id="saveBtn">Kaydet</button>
			</div>
			<div id="toolbar">
				<button class="ql-bold"></button>
				<button class="ql-italic"></button>
				<button class="ql-underline"></button>
			</div>
			<div id="editor"></div>
		</header>
		<main>
			<table>
				<thead>
					<tr>
						<th>Ba≈ülƒ±k</th>
						<th>Tarih</th>
						<th>Durum</th>
						<th>ƒ∞≈ülem</th>
					</tr>
				</thead>
				<tbody id="notesTable"></tbody>
			</table>
			<h3>Durum Loglarƒ±</h3>
			<div id="status"></div>
			<!-- History Modal -->
			<div id="historyModal" style="display:none" class="history-modal">
				<h3>Revision History</h3>
				<table style="width:100%; border-collapse:collapse;">
					<thead>
						<tr>
							<th>Tarih</th>
							<th>ƒ∞≈ülem</th>
						</tr>
					</thead>
					<tbody id="historyTable"></tbody>
				</table>
				<button onclick="closeHistoryModal()">Kapat</button>
			</div>
			<div id="historyOverlay"></div>
		</main>
		<script>
			// ==========================
			// Yardƒ±mcƒ±lar
			// ==========================
			const $ = s => document.querySelector(s);
			const log = (m, t = "log") => {
				const ts = new Date().toISOString().substr(11, 8);
				$('#status').textContent += `[${ts}] ${m}\n`;
				$('#status').scrollTop = $('#status').scrollHeight;
				console[t](m);
			};
			
			// Resim sƒ±kƒ±≈ütƒ±rma fonksiyonu
			function compressImage(base64, maxWidth = 800, quality = 0.8) {
				return new Promise((resolve) => {
					const img = new Image();
					img.onload = () => {
						const canvas = document.createElement('canvas');
						const ctx = canvas.getContext('2d');
						
						// Boyutlarƒ± hesapla
						const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
						canvas.width = img.width * ratio;
						canvas.height = img.height * ratio;
						
						// Resmi √ßiz
						ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
						
						// Sƒ±kƒ±≈ütƒ±r
						const compressed = canvas.toDataURL('image/jpeg', quality);
						resolve(compressed);
					};
					img.src = base64;
				});
			}

			const quill = new Quill('#editor', {
				theme: 'snow',
				modules: {
					toolbar: '#toolbar'
				}
			});

			// Resim yapƒ±≈ütƒ±rma sƒ±nƒ±rlamasƒ±
			quill.clipboard.addMatcher(Node.ELEMENT_NODE, (node, delta) => {
				if (node.tagName === 'IMG') {
					const src = node.getAttribute('src');
					if (src && src.startsWith('data:image')) {
						// Base64 resim boyutunu kontrol et
						const sizeInBytes = (src.length * 3) / 4;
						if (sizeInBytes > 1024 * 1024) { // 1MB sƒ±nƒ±rƒ±
							log('üñºÔ∏è Resim √ßok b√ºy√ºk, sƒ±kƒ±≈ütƒ±rƒ±lƒ±yor...');
							// Resmi sƒ±kƒ±≈ütƒ±r (asenkron i≈ülem i√ßin setTimeout kullan)
							setTimeout(async () => {
								try {
									const compressed = await compressImage(src);
									// Mevcut delta'yƒ± temizle ve yeni resmi ekle
									const currentLength = quill.getLength();
									quill.deleteText(0, currentLength);
									quill.insertEmbed(0, 'image', compressed);
									log('‚úÖ Resim sƒ±kƒ±≈ütƒ±rƒ±ldƒ± ve eklendi');
								} catch (error) {
									log(`‚ùå Resim sƒ±kƒ±≈ütƒ±rma hatasƒ±: ${error.message}`, "error");
								}
							}, 0);
							// Bo≈ü delta d√∂nd√ºr, asƒ±l i≈ülem setTimeout'ta yapƒ±lacak
							return { ops: [] };
						}
					}
				}
				return delta;
			});
			
			const db = new Dexie('noteflix');
			db.version(1).stores({
				notes: 'id,title,plainText,pendingInt,cachedInt,createdAt,updatedAt,accessedAt,googleFileId,isDeleted,revision',
				secureStorage: 'key'
			});
			
			const GOOGLE_CLIENT_ID = "888004155857-u09rcm3g84iqief0c2hs03kci3psr7ib.apps.googleusercontent.com";
			let accessToken = null,
				tokenClient = null,
				appFolderId = null,
				currentNoteId = null,
				masterKey = null,
				userEmail = null;

			// ==========================
			// G√ºvenli Storage (IndexedDB)
			// ==========================
			const secureStorage = {
				async setItem(key, value) {
					try {
						await db.table('secureStorage').put({ key, value, timestamp: Date.now() });
					} catch (e) {
						log(`Secure storage set error: ${e.message}`, "error");
					}
				},
				
				async getItem(key) {
					try {
						const result = await db.table('secureStorage').get(key);
						return result ? result.value : null;
					} catch (e) {
						log(`Secure storage get error: ${e.message}`, "error");
						return null;
					}
				},
				
				async removeItem(key) {
					try {
						await db.table('secureStorage').delete(key);
					} catch (e) {
						log(`Secure storage remove error: ${e.message}`, "error");
					}
				},
				
				async clear() {
					try {
						await db.table('secureStorage').clear();
					} catch (e) {
						log(`Secure storage clear error: ${e.message}`, "error");
					}
				}
			};

			// ==========================
			// Google Token
			// ==========================
			async function saveGoogleAuthState(token, email) {
				await secureStorage.setItem('google_token', token);
				await secureStorage.setItem('google_email', email);
			}

			async function loadGoogleAuthState() {
				const token = await secureStorage.getItem('google_token');
				const email = await secureStorage.getItem('google_email');
				return { token, email };
			}

			async function clearGoogleAuthState() {
				await secureStorage.removeItem('google_token');
				await secureStorage.removeItem('google_email');
				await clearMasterKey();
				masterKey = null;
			}

			// ==========================
			// Master Key G√ºvenli Storage
			// ==========================
			async function saveMasterKey(key) {
				// Master key'i session-based sakla (tarayƒ±cƒ± kapandƒ±ƒüƒ±nda silinsin)
				sessionStorage.setItem('noteflix_master_key', JSON.stringify(Array.from(key)));
			}

			async function loadMasterKey() {
				try {
					const stored = sessionStorage.getItem('noteflix_master_key');
					if (stored) {
						const keyArray = JSON.parse(stored);
						// CryptoKey objesi geri y√ºklenemez, yeniden t√ºretilmeli
						return null; // Force re-derivation for security
					}
				} catch (e) {
					log(`Master key load error: ${e.message}`, "error");
				}
				return null;
			}

			async function clearMasterKey() {
				sessionStorage.removeItem('noteflix_master_key');
			}
			
			async function restoreGoogleAuth() {
				const { token, email } = await loadGoogleAuthState();
				if (token) {
					try {
						// Token'ƒ±n hala ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
						accessToken = token;
						userEmail = email;
						gapi.client.setToken({
							access_token: accessToken
						});
						
						// Token'ƒ± test et
						const testResponse = await fetch('https://www.googleapis.com/oauth2/v1/userinfo?access_token=' + accessToken);
						if (testResponse.ok) {
							$('#who').textContent = email ? `Baƒülƒ±: ${email}` : 'Baƒülƒ±';
							$('#googleConnectBtn').textContent = 'Baƒülantƒ±yƒ± Kes';
							log("‚úÖ Google baƒülantƒ±sƒ± otomatik olarak geri y√ºklendi");
							
							// Master key'i y√ºkle (session-based)
							const loadedKey = await loadMasterKey();
							if (loadedKey) {
								masterKey = loadedKey;
								log("üîë Master key session'dan y√ºklendi");
							} else {
								// Master key yoksa yeniden t√ºret
								masterKey = await deriveKey(email || "demo", "salt");
								await saveMasterKey(masterKey);
								log("üîë Master key yeniden t√ºretildi");
							}
							
							await ensureFolder();
						} else {
							// Token ge√ßersiz, temizle
							clearGoogleAuthState();
							accessToken = null;
							userEmail = null;
							log("‚ö†Ô∏è Kaydedilmi≈ü token ge√ßersiz, temizlendi");
						}
					} catch (e) {
						// Token ge√ßersiz, temizle
						clearGoogleAuthState();
						accessToken = null;
						userEmail = null;
						log("‚ö†Ô∏è Kaydedilmi≈ü baƒülantƒ± geri y√ºklenemedi: " + e.message);
					}
				}
			}
			
			async function initGapi() {
				try {
					// gapi'nin y√ºklenmesini bekle
					await new Promise(resolve => {
						if (typeof gapi !== 'undefined') {
							resolve();
						} else {
							const checkGapi = () => {
								if (typeof gapi !== 'undefined') {
									resolve();
								} else {
									setTimeout(checkGapi, 100);
								}
							};
							checkGapi();
						}
					});
					await new Promise(res => gapi.load('client', res));
					await gapi.client.init({
						discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
					});
					log("‚úÖ Google API ba≈üarƒ±yla y√ºklendi");
					
					// Sayfa y√ºklendiƒüinde kaydedilmi≈ü baƒülantƒ± durumunu kontrol et
					await restoreGoogleAuth();
				} catch (e) {
					log("‚ùå Google API y√ºkleme hatasƒ±: " + e.message, "error");
				}
			}
			
			// ==========================
			// OPFS
			// ==========================
			async function opfsRoot() {
				return await navigator.storage.getDirectory();
			}

			async function opfsWrite(name, content) {
				try {
					const r = await opfsRoot();
					const h = await r.getFileHandle(name, {
						create: true
					});
					const w = await h.createWritable();
					await w.write(content);
					await w.close();
				} catch {}
			}

			async function opfsRead(name) {
				try {
					const r = await opfsRoot();
					const h = await r.getFileHandle(name);
					const f = await h.getFile();
					return await f.text();
				} catch {
					return null;
				}
			}

			async function opfsDelete(name) {
				try {
					const r = await opfsRoot();
					await r.removeEntry(name);
				} catch {}
			}

			// ==========================
			// Crypto + Compression
			// ==========================
			async function generateHashedKey(email) {
				// 1. Email string'ini UTF-8 byte array'e √ßevir
				const encoder = new TextEncoder();
				const data = encoder.encode(email);
				// 2. SHA-256 ile hashle
				const hashBuffer = await crypto.subtle.digest("SHA-256", data);
				// 3. Hash sonucunu hex string'e √ßevir
				const hashArray = Array.from(new Uint8Array(hashBuffer));
				const hashHex = hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
				return hashHex; // 64 karakterlik hex string (256-bit key)
			}

			async function deriveKey(email, salt) {
				const keyString = await generateHashedKey(email + salt);
				// Hex string'i byte array'e √ßevir
				const keyBytes = new Uint8Array(keyString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
				return await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["encrypt", "decrypt"]);
			}

			async function encryptJSON(key, obj) {
				const iv = crypto.getRandomValues(new Uint8Array(12));
				const json = JSON.stringify(obj);
				const compressed = fflate.strToU8(json);
				const cipher = await crypto.subtle.encrypt({
					name: "AES-GCM",
					iv
				}, key, compressed);
				return {
					iv: Array.from(iv),
					cipher: Array.from(new Uint8Array(cipher))
				};
			}

			async function decryptJSON(key, iv, cipher) {
				const c = new Uint8Array(cipher);
				const d = await crypto.subtle.decrypt({
					name: "AES-GCM",
					iv: new Uint8Array(iv)
				}, key, c);
				const u = fflate.strFromU8(new Uint8Array(d));
				return JSON.parse(u);
			}

			// ==========================
			// Google Drive
			// ==========================
			async function driveCreateJson(folderId, name, appProperties, envelope) {
				log(`üìÑ driveCreateJson folderId: ${folderId}, name: ${name}`);
				log(`üìÑ appProperties: ${JSON.stringify(appProperties)}`);
				const content = JSON.stringify(envelope);
				const blob = new Blob([content], {
					type: "application/json"
				});
				const metadata = {
					name: name,
					mimeType: "application/json",
					parents: [folderId],
					appProperties: appProperties
				};
				const form = new FormData();
				form.append("metadata", new Blob([JSON.stringify(metadata)], {
					type: "application/json"
				}));
				form.append("file", blob);
				const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
					method: "POST",
					headers: {
						Authorization: "Bearer " + accessToken
					},
					body: form
				});
				if (!res.ok) {
					const errorData = await res.json();
					log(`‚ùå driveCreateJson error: ${errorData.error?.message || res.statusText}`, "error");
					throw new Error(`File creation error: ${errorData.error?.message || res.statusText}`);
				}
				return {
					result: await res.json()
				};
			}

			async function driveUpdateJson(fileId, folderId, name, appProperties, envelope) {
				log(`üìÑ driveUpdateJson fileId: ${fileId}, folderId:${folderId}, name: ${name}`);
				log(`üìÑ appProperties: ${JSON.stringify(appProperties)}`);
				const content = JSON.stringify(envelope);
				const blob = new Blob([content], {
					type: "application/json"
				});
				const metadata = {
					name: name,
					mimeType: "application/json",
					appProperties: appProperties
				};
				const form = new FormData();
				form.append("metadata", new Blob([JSON.stringify(metadata)], {
					type: "application/json"
				}));
				form.append("file", blob);
				const res = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, {
					method: "PATCH",
					headers: {
						Authorization: "Bearer " + accessToken
					},
					body: form
				});
				if (!res.ok) {
					const errorData = await res.json();
					log(`‚ùå driveUpdateJson error: ${errorData.error?.message || res.statusText}`, "error");
					throw new Error(`File update error: ${errorData.error?.message || res.statusText}`);
				}
				return {
					result: await res.json()
				};
			}

			async function driveSyncJson(folderId, entityId, updatedAt, revision, envelope, googleFiles = null) {
				log("driveSyncJson");
				const name = `${entityId}.json`;
				const appProperties = {
					app: 'noteflix',
					entityId,
					updatedAt,
					revision
				};
				let files = [];
				if (googleFiles) {
					files = googleFiles.filter(f => f.appProperties?.entityId === entityId);
					log(`üîç Searching for ${entityId} in the given list...`);
				}
				
				if (files.length === 0) {
					log(`Not found in the given list or the list is null, search from Google Drive`);
					const q = `'${folderId}' in parents and appProperties has { key='entityId' and value='${entityId}' } and trashed=false`;
					try {
						// gapi.client.drive.files.list yerine fetch API kullan
						const response = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&spaces=drive&fields=files(id,name,appProperties)`, {
							method: "GET",
							headers: {
								"Authorization": `Bearer ${accessToken}`
							}
						});
						
						if (!response.ok) {
							const errorData = await response.json();
							throw new Error(`File search error: ${errorData.error?.message || response.statusText}`);
						}
						
						const data = await response.json();
						files = data.files || [];
						log(`üîç Searching for ${entityId} in Google Drive...`);
					} catch (error) {
						log(`‚ùå driveSyncJson error: ${error.message}`, "error");
						throw error;
					}
				}
				
				if (files.length > 0) {
					log(`üîÑ Updating ${entityId}...`);
					return await driveUpdateJson(files[0].id, folderId, name, appProperties, envelope);
				} else {
					log(`üì§ Creating ${entityId}...`);
					return await driveCreateJson(folderId, name, appProperties, envelope);
				}
			}

			async function listRevisions(fileId) {
				const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/revisions?fields=revisions(id,modifiedTime,keepForever)`, {
					headers: { Authorization: `Bearer ${accessToken}` }
				});
				if (!res.ok) throw new Error("Revision list error");
				const data = await res.json();
				return data.revisions || [];
			}
			
			async function getRevision(fileId, revId) {
				// Revision i√ßeriƒüini almak i√ßin alt=media parametresi ile dosya i√ßeriƒüini √ßekiyoruz
				const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/revisions/${revId}?alt=media`, {
					headers: { Authorization: `Bearer ${accessToken}` }
				});
				if (!res.ok) throw new Error(`Revision get error: ${res.status} ${res.statusText}`);
				
				const text = await res.text();
				
				try {
					const data = JSON.parse(text);
					return data;
				} catch (parseError) {
					throw new Error(`Failed to parse revision content: ${parseError.message}`);
				}
			}			

			async function ensureFolder() {
				if (appFolderId) {
					log(`üìÅ NoteFlix already defined: ${appFolderId}`);
					return appFolderId;
				}
				
				log("üîç NoteFlix folder searching...");
				const q = "mimeType='application/vnd.google-apps.folder' and name='Noteflix' and trashed=false";
				try {
					// gapi.client.drive.files.list yerine fetch API kullan
					const listResponse = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&spaces=drive&fields=files(id,name)`, {
						method: "GET",
						headers: {
							"Authorization": `Bearer ${accessToken}`
						}
					});
					
					if (!listResponse.ok) {
						const errorData = await listResponse.json();
						throw new Error(`Folder listing error: ${errorData.error?.message || listResponse.statusText}`);
					}
					
					const listData = await listResponse.json();
					if (listData.files.length) {
						appFolderId = listData.files[0].id;
						log(`‚úÖ NoteFlix folder found: ${appFolderId}`);
						return appFolderId;
					}
					
					log("üìÅ NoteFlix folder creating...");
					// gapi.client.drive.files.create yerine fetch API kullan
					const createResponse = await fetch("https://www.googleapis.com/drive/v3/files", {
						method: "POST",
						headers: {
							"Authorization": `Bearer ${accessToken}`,
							"Content-Type": "application/json"
						},
						body: JSON.stringify({
							name: 'NoteFlix',
							mimeType: 'application/vnd.google-apps.folder'
						})
					});
					
					if (!createResponse.ok) {
						const errorData = await createResponse.json();
						throw new Error(`Folder creating error: ${errorData.error?.message || createResponse.statusText}`);
					}
					
					const createData = await createResponse.json();
					appFolderId = createData.id;
					log(`‚úÖ NoteFlix folder created: ${appFolderId}`);
					return appFolderId;
				} catch (e) {
					log(`‚ùå Google Drive folder error: ${e.message}`, "error");
					if (e.message.includes("network") || e.message.includes("internet") || e.message.includes("ERR_INTERNET_DISCONNECTED")) {
						log(`‚ö†Ô∏è No internet connection, folder operation cannot be performed.`);
					}
					throw e; 
				}
			}
			
			// ==========================
			// History
			// ==========================			
			async function showHistory(noteId) {
				const note = await db.notes.get(noteId);
				if (!note?.googleFileId) {
					alert("‚ö†Ô∏è Bu not Google Drive ile senkronize deƒüil, history yok.");
					return;
				}
				
				if (!navigator.onLine) {
					alert("‚ö†Ô∏è No internet connection");
					return;
				}
				
				if (!accessToken) {
					alert("‚ö†Ô∏èNot connected to Google Drive");
					return;
				}

				try {
					const revisions = await listRevisions(note.googleFileId);
					const tbody = document.getElementById("historyTable");
					tbody.innerHTML = "";

					revisions.forEach(r => {
						const tr = document.createElement("tr");
						tr.innerHTML = `
							<td>${new Date(r.modifiedTime).toLocaleString()}</td>
							<td>
								<button onclick="previewRevision('${note.googleFileId}','${r.id}')">Preview</button>
								<button onclick="restoreRevision('${note.googleFileId}','${r.id}','${noteId}')">Restore</button>
							</td>`;
						tbody.appendChild(tr);
					});

					document.getElementById("historyModal").style.display = "block";
				} catch (e) {
					log(`‚ùå History list error: ${e.message}`, "error");
				}
			}

			function closeHistoryModal() {
				document.getElementById("historyModal").style.display = "none";
			}
			
			async function previewRevision(fileId, revisionId) {
				try {
					const env = await getRevision(fileId, revisionId);
					
					// Veri kontrol√º eklendi
					if (!env || !env.iv || !env.cipher) {
						throw new Error("Revision data is missing required fields");
					}
					
					if (env.cipher.length < 16) { // AES-GCM i√ßin minimum cipher uzunluƒüu
						throw new Error(`Cipher data too small: ${env.cipher.length} bytes`);
					}
					
					const key = masterKey || await deriveKey(userEmail || "demo", "salt");
					const note = await decryptJSON(key, env.iv, env.cipher);

					alert(`üìÑ Preview\nBa≈ülƒ±k: ${note.title}\nTarih: ${note.updatedAt}\nƒ∞√ßerik: ${note.contentText?.slice(0,100)}...`);
				} catch (e) {
					log(`‚ùå Preview error: ${e.message}`, "error");
				}
			}

			async function restoreRevision(fileId, revId, noteId) {
				const env = await getRevision(fileId, revId);
				await opfsWrite(noteId + ".json", JSON.stringify(env));
				const key = masterKey || await deriveKey(userEmail || "demo", "salt");
				const note = await decryptJSON(key, env.iv, env.cipher);
				currentNoteId = noteId;
				
				saveNote(note.title, note.delta, note.deltatext);

				currentNoteId = null;
				log(`‚úÖ Revision ${revId} restored for ${noteId}`);
			}
			
			// ==========================
			// Save/Copy/Delete/Load Note
			// ==========================
			async function saveNote(title, delta, deltaText) {
				log("saveNote");
				//prepare properties
				const id = currentNoteId || ('n_' + Date.now());
				//const title = $('#title').value;				
				//const delta = quill ? quill.getContents() : '';
				//const deltaText = quill ? quill.getText().trim() : '';				
				const existingNote = currentNoteId ? await db.notes.get(currentNoteId) : null;				
				const now = new Date().toISOString();
				const revision = (existingNote?.revision || 0) + 1;
				
				//write OPFS
				const plain = {
					id,
					title,
					updatedAt: now,
					revision,
					content: delta,
					contentText: deltaText
				};
				
				const key = await deriveKey(userEmail || "demo", "salt");
				masterKey = key;
				await saveMasterKey(key);
				const env = await encryptJSON(key, plain);				
				await opfsWrite(id + ".json", JSON.stringify(env));
				
				//save indexedDB				
				await db.notes.put({
				  id,
				  title,
				  plainText: deltaText,
				  pendingInt: 1,	//not syncronized with google drive yet
				  cachedInt: 1,		//written to opfs
				  createdAt: existingNote ? existingNote.createdAt : now,
				  updatedAt: now,
				  accessedAt: Date.now(),
				  googleFileId: existingNote ? existingNote.googleFileId : null ,
				  isDeleted: 0,
				  revision
				});
				
				currentNoteId = id;
				//refresh note list
				await refreshList();
				log(`üîÑ ${id} Google Drive is synchronizing...`);
				
				// ƒ∞nternet baƒülantƒ±sƒ± varsa ve google drive'a baƒülandƒ±ysa
				if (navigator.onLine && accessToken) {
					try {
						await ensureFolder();
						
						log("üîÑ ${id} Google Drive is syncronizing...");
						const result = await driveSyncJson(appFolderId, id, now, revision, env);
						
						await db.notes.update(id, {
							pendingInt: 0,
							googleFileId: result.result.id
						});
						log(`‚úÖ ${id} Google Drive syncronized succesfully`);
						
						await refreshList();
					} catch (e) {
						log(`‚ùå ${id} Google Drive syncronizing error: ${e.message}`, "error");
						// ƒ∞nternet hatasƒ± durumunda sadece yerel kayƒ±t yapƒ±ldƒ±ƒüƒ±nƒ± belirt
						if (e.message.includes("network") || e.message.includes("internet") || e.message.includes("ERR_INTERNET_DISCONNECTED")) {
							alert(`‚ö†Ô∏è No internet connection, only saved to local db. It will sync when the internet is available.`);
						}
						else{
							alert(`‚ùå ${id} Google Drive sync error: ${e.message}`, "error");
						}
					}
				} else {
					if (!navigator.onLine) {
						alert("‚ö†Ô∏è No internet connection, only saved to local db");
					} else if (!accessToken) {
						alert("‚ö†Ô∏èNot connected to Google Drive, only saved to local db");
					}
				}			
			}

			async function copyNote(id) {
				log(`üìã ${id} notu kopyalanƒ±yor...`);
				
				try {
					// 1. Orijinal notu oku
					const originalNote = await db.notes.get(id);
					if (!originalNote) {
						log(`‚ùå ${id} notu bulunamadƒ±`, "error");
						return;
					}
					
					// 2. OPFS'ten i√ßeriƒüi oku
					const txt = await opfsRead(id + ".json");
					if (!txt) {
						log(`‚ùå ${id} i√ßin OPFS dosyasƒ± bulunamadƒ±`, "error");
						return;
					}
					
					// 3. ƒ∞√ßeriƒüi √ß√∂z
					const env = JSON.parse(txt);
					const key = masterKey || await deriveKey(userEmail || "demo", "salt");
					const noteContent = await decryptJSON(key, env.iv, env.cipher);
					
					// 4. Yeni ID olu≈ütur
					const newId = 'n_' + Date.now();
					const now = new Date().toISOString();
					const revision = 1;
					
					// 5. Kopyalanan not i√ßin yeni i√ßerik olu≈ütur
					const copiedContent = {
						id: newId,
						title: noteContent.title + ' (Kopya)',
						createdAt: now,
						updatedAt: now,
						content: noteContent.content,
						contentText: noteContent.contentText
					};
					
					// 6. Yeni notu ≈üifrele ve OPFS'e kaydet
					const newEnv = await encryptJSON(key, copiedContent);
					await opfsWrite(newId + ".json", JSON.stringify(newEnv));
					
					// 7. IndexedDB'ye yeni kayƒ±t ekle
					await db.notes.put({
						id: newId,
						title: copiedContent.title,
						plainText: originalNote.plainText,
						pendingInt: 1, // Yeni not, senkronize edilmeli
						cachedInt: 1,
						createdAt: now,
						updatedAt: now,
						accessedAt: Date.now(),
						googleFileId: null, // Yeni not, hen√ºz Google Drive'da yok
						isDeleted: 0,
						revision: 1
					});
					
					// 8. Liste g√ºncelle
					await refreshList();
					log(`‚úÖ ${id} ba≈üarƒ±yla kopyalandƒ± (Yeni ID: ${newId})`);
					
					// 9. Eƒüer online ise Google Drive'a da senkronize et
					if (navigator.onLine && accessToken) {
						try {
							await ensureFolder();
							log(`üîÑ ${newId} Google Drive'a senkronize ediliyor...`);
							const result = await driveSyncJson(appFolderId, newId, now, revision, newEnv);
							await db.notes.update(newId, {
								pendingInt: 0,
								googleFileId: result.result.id
							});
							log(`‚úÖ ${newId} Google Drive'a ba≈üarƒ±yla senkronize edildi`);
							await refreshList();
						} catch (e) {
							log(`‚ùå ${newId} Google Drive senkronizasyon hatasƒ±: ${e.message}`, "error");
						}
					}
					
				} catch (e) {
					log(`‚ùå ${id} kopyalama hatasƒ±: ${e.message}`, "error");
				}
			}

			async function deleteNote(id) {
				log(`üóëÔ∏è ${id} notu siliniyor...`);
				
				try {
					// 0. √ñnce not kaydƒ±nƒ± al
					const noteRecord = await db.notes.get(id);
					if (!noteRecord) {
						log(`‚ùå ${id} notu bulunamadƒ±`, "error");
						return;
					}
					// 1. IndexedDB'de soft delete yap
					await db.notes.update(id, {
						isDeleted: 1,
						updatedAt: new Date().toISOString()
					});
						
					// 2. OPFS dosyasƒ±nƒ± sil
					await opfsDelete(id + ".json");
					log(`‚úÖ ${id} OPFS dosyasƒ± silindi`);
					
					// 3. Liste g√ºncelle
					await refreshList();
					
					// 4. Not Google Drive'a entegre edilmi≈ü, Drive'da da silindi olarak i≈üaretle
					if (noteRecord.googleFileId) {					
						// Google Drive i≈ülemi i√ßin internet ve token kontrol√º
						if (navigator.onLine && accessToken) {
							try {		
								await ensureFolder();
								
								// Mevcut dosyayƒ± oku
								const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${noteRecord.googleFileId}?alt=media`, {
									method: "GET",
									headers: {
										"Authorization": `Bearer ${accessToken}`
									}
								});
								
								if (fileResponse.ok) {
									const fileBody = await fileResponse.text();
									const envelope = JSON.parse(fileBody);
									
									// appSettings'e isDeleted ekle
									envelope.appSettings = envelope.appSettings || {};
									envelope.appSettings.isDeleted = 1;
									
									// G√ºncellenmi≈ü dosyayƒ± Drive'a geri yaz
									const appProperties = {
										app: 'noteflix',
										entityId: id,
										updatedAt: new Date().toISOString(),
										isDeleted: 1
									};
									
									await driveUpdateJson(noteRecord.googleFileId, appFolderId, `${id}.json`, appProperties, envelope);
									log(`‚úÖ ${id} Google Drive'da silindi olarak i≈üaretlendi`);
								}
							} catch (e) {
								log(`‚ùå ${id} Google Drive g√ºncelleme hatasƒ±: ${e.message}`, "error");
							}
						} else {
							log(`‚ö†Ô∏è ${id} Google Drive g√ºncellemesi yapƒ±lamadƒ± (internet/token yok), sadece yerel silme yapƒ±ldƒ±`);
						}
					} else {
						// Not hen√ºz Google Drive'a entegre edilmemi≈ü, IndexedDB'den tamamen sil
						await db.notes.delete(id);
						log(`‚úÖ ${id} IndexedDB'den tamamen silindi (Google Drive entegrasyonu yok)`);
					}
					
					log(`‚úÖ ${id} ba≈üarƒ±yla silindi`);
					
				} catch (e) {
					log(`‚ùå ${id} silme hatasƒ±: ${e.message}`, "error");
				}
			}

			async function loadNote(id) {
				const txt = await opfsRead(id + ".json");
				currentNoteId = id;
				
				if (txt) {
					try {
						const env = JSON.parse(txt);
						const key = masterKey || await deriveKey(userEmail || "demo", "salt");
						const note = await decryptJSON(key, env.iv, env.cipher);
						
						$('#title').value = note.title;
						quill.setContents(note.content);						
						await db.notes.update(id, {
							accessedAt: Date.now()
						});
						log("‚¨áÔ∏è OPFS'ten y√ºklendi: " + id);
						return;
					} catch {}
				}
				// OPFS'te bulunamadƒ±, Google Drive'dan oku
				if (navigator.onLine && accessToken) {
					try {
						await ensureFolder();
					
						const noteRecord = await db.notes.get(id);
						if (noteRecord && noteRecord.googleFileId) {
							log(`üì• ${id} Google Drive'dan y√ºkleniyor...`);
							const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${noteRecord.googleFileId}?alt=media`, {
								method: "GET",
								headers: {
									"Authorization": `Bearer ${accessToken}`
								}
							});
							
							if (!fileResponse.ok) {
								const errorData = await fileResponse.json();
								throw new Error(`Dosya indirme hatasƒ±: ${errorData.error?.message || fileResponse.statusText}`);
							}
							
							const fileBody = await fileResponse.text();
							const file = { body: fileBody };
							// OPFS'e kaydet
							await opfsWrite(id + ".json", file.body);
							// ≈ûifreli i√ßeriƒüi √ß√∂z
							const env = JSON.parse(file.body);
							const key = masterKey || await deriveKey(userEmail || "demo", "salt");
							const note = await decryptJSON(key, env.iv, env.cipher);
							
							$('#title').value = note.title;
							quill.setContents(note.content);
							currentNoteId = id;
							
							await db.notes.update(id, {
								accessedAt: Date.now(),
								cachedInt: 1
							});
							log("‚¨áÔ∏è Google Drive'dan y√ºklendi: " + id);
							return;
						}
					} catch (e) {
						log(`‚ùå Google Drive'dan y√ºkleme hatasƒ±: ${e.message}`, "error");
					}
				}
				log(`‚ö†Ô∏è ${id} notu bulunamadƒ±`);
			}

			// ==========================
			// SynchronizeGoogleDrive (pull+push)
			// ==========================
			async function SynchronizeGoogleDrive() {
				if (!accessToken || !navigator.onLine) {
					log("üì¥ Senkronizasyon yapƒ±lamƒ±yor");
					return;
				}
				await ensureFolder();
				
				// pull from Google Drive
				const q = `'${appFolderId}' in parents and mimeType='application/json' and trashed=false`;
				const listResponse = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&fields=files(id,name,appProperties)&pageSize=1000`, {
					method: "GET",
					headers: {
						"Authorization": `Bearer ${accessToken}`
					}
				});
				
				if (!listResponse.ok) {
					const errorData = await listResponse.json();
					throw new Error(`Drive dosya listesi hatasƒ±: ${errorData.error?.message || listResponse.statusText}`);
				}
				
				const listData = await listResponse.json();
				const driveFiles = listData.files;
				log(`üì• Drive'dan ${driveFiles.length} dosya listelendi`);
				
				const localNotes = await db.notes.toArray();
				const localMap = new Map(localNotes.map(n => [n.id, n]));
				
				for (const f of driveFiles) {
					// appProperties'den noteId'yi al
					const id = f.appProperties?.entityId || (f.name.endsWith('.json') ? f.name.slice(0, -5) : f.name);
					const driveUpdated = new Date(f.appProperties?.updatedAt);
					const local = localMap.get(id);
					
					if (!local) {
						// √ñnce OPFS'te dosya var mƒ± kontrol et
						const existingOpfsContent = await opfsRead(id + ".json");
						if (existingOpfsContent) {
							// OPFS'te dosya var, tarihleri kar≈üƒ±la≈ütƒ±r
							try {
								const existingEnv = JSON.parse(existingOpfsContent);
								const key = masterKey || await deriveKey(userEmail || "demo", "salt");
								const opfsNote = await decryptJSON(key, existingEnv.iv, existingEnv.cipher);
								const opfsNoteUpdated = new Date(opfsNote.updatedAt);
								
								if (opfsNoteUpdated > driveUpdated) {
									log(`‚ö†Ô∏è ${id} lokaldeki daha g√ºncel, Drive'dan indirilmedi`);
									// Lokaldeki daha g√ºncel, sadece googleFileId'yi kaydet
									  await db.notes.put({
										id,
										title: opfsNote.title,
										plaintext: opfsNote.contentText,
										createdAt: opfsNote.createdAt,  // Mevcut createdAt'i koru
										updatedAt: opfsNote.updatedAt,
										pendingInt: 1, // Lokaldeki daha g√ºncel, senkronize et
										cachedInt: 1,
										isDeleted: 0,
										accessedAt: Date.now(),
										googleFileId: f.id,
										revision: opfsNote.revision
									  });
									continue; // Sonraki dosyaya ge√ß
								}
							} catch (e) {
								log(`‚ö†Ô∏è ${id} OPFS dosyasƒ± okunamadƒ±, Drive'dan indiriliyor`);
							}
						}
						// Drive'daki daha g√ºncel veya OPFS'te dosya yok
						const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${f.id}?alt=media`, {
							method: "GET",
							headers: {
								"Authorization": `Bearer ${accessToken}`
							}
						});
						
						if (!fileResponse.ok) {
							const errorData = await fileResponse.json();
							throw new Error(`Dosya indirme hatasƒ±: ${errorData.error?.message || fileResponse.statusText}`);
						}
						
						const fileBody = await fileResponse.text();
						const file = { body: fileBody };
						
						const envTemp = JSON.parse(file.body);
						const keyTemp = masterKey || await deriveKey(userEmail || "demo", "salt");
						const noteTemp = await decryptJSON(keyTemp, envTemp.iv, envTemp.cipher);

						await opfsWrite(id + ".json", file.body);
						
						await db.notes.put({
						  id,
						  title: noteTemp.title,
						  plainText: noteTemp.contentText,
						  createdAt: noteTemp.createdAt,  // Drive'dan indirilen dosya i√ßin creation time
						  updatedAt: noteTemp.updatedAt,
						  pendingInt: 0,
						  cachedInt: 1,
						  isDeleted: f.appProperties?.isDeleted || '0',
						  accessedAt: Date.now(),
						  googleFileId: f.id, // Drive'dan indirilen dosyanƒ±n ID'sini kaydet
						  revision: noteTemp.revision
						});
						log(`‚¨áÔ∏è ${id} Drive'dan indirildi`);
					} else {
						const localUpdated = new Date(local.updatedAt);
						
						if (driveUpdated > localUpdated) {
							const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${f.id}?alt=media`, {
								method: "GET",
								headers: {
									"Authorization": `Bearer ${accessToken}`
								}
							});
							
							if (!fileResponse.ok) {
								const errorData = await fileResponse.json();
								throw new Error(`Dosya indirme hatasƒ±: ${errorData.error?.message || fileResponse.statusText}`);
							}
							
							const fileBody = await fileResponse.text();
							const file = { body: fileBody };
							await opfsWrite(id + ".json", file.body);
							
							const envTemp = JSON.parse(file.body);
							const keyTemp = masterKey || await deriveKey(userEmail || "demo", "salt");
							const noteTemp = await decryptJSON(keyTemp, envTemp.iv, envTemp.cipher);
							
							await db.notes.put({								
								id,
								title: noteTemp.title,
								plainText: noteTemp.contentText,
								createdAt: noteTemp.createdAt,  // Drive'dan indirilen dosya i√ßin creation time
								updatedAt: noteTemp.updatedAt,
								pendingInt: 0,
								cachedInt: 1,
								isDeleted: noteTemp?.isDeleted || '0',
								accessedAt: Date.now(),
								googleFileId: f.id, // Drive'dan indirilen dosyanƒ±n ID'sini kaydet
								revision: noteTemp.revision
							});
						}
					}
				}
				// push to Google Drive
				const pendings = await db.notes.where("pendingInt").equals(1).toArray();
				log(`üì§ ${pendings.length} pending not bulundu`);
				for (const n of pendings) {
					try {
						const txt = await opfsRead(n.id + ".json");
						if (!txt) {
							log(`‚ö†Ô∏è ${n.id} i√ßin OPFS dosyasƒ± bulunamadƒ±`);
							continue;
						}
						// Envelope formatƒ±nƒ± olu≈ütur
						const envelope = JSON.parse(txt);
						envelope.meta = envelope.meta || {
							rev: 0
						};
						let result;
						/*
						if (n.googleFileId) {
							// Dosya zaten Drive'da var, direkt g√ºncelle
							log(`üîÑ ${n.id} g√ºncelleniyor (ID: ${n.googleFileId})...`);
							result = await driveUpdateJson(n.googleFileId, appFolderId, `${n.id}.json`, {
								app: 'Noteflix',
								entityId: n.id
							}, envelope);
						} else {
							// ƒ∞lk kez Drive'a y√ºkleniyor
							log(`üì§ ${n.id} ilk kez Drive'a y√ºkleniyor...`);
							result = await driveSyncJson(appFolderId, n.id, n.updatedAt, n.revision, envelope, driveFiles);
						}
						*/
						result = await driveSyncJson(appFolderId, n.id, n.updatedAt, n.revision, envelope, driveFiles);
						
						log(`‚úÖ ${n.id} ba≈üarƒ±yla i≈ülendi: ${result.result.name} (ID: ${result.result.id})`);
						await db.notes.update(n.id, {
							pendingInt: 0,
							googleFileId: result.result.id // Google File ID'yi kaydet
						});
						
						log(`‚úÖ ${n.id} ba≈üarƒ±yla senkronize edildi`);
					} catch (e) {
						log(`‚ùå ${n.id} senkronizasyon hatasƒ±: ${e.message}`, "error");
					}
				}
				log("‚úÖ Senkronizasyon tamamlandƒ±");
				await refreshList();
			}
			
			window.addEventListener("online", () => {
				SynchronizeGoogleDrive();
			});

			// ==========================
			// Background Preload
			// ==========================
			async function backgroundPreload() {				
				if (!accessToken || !navigator.onLine) return;
				const metas = await db.notes.where("cachedInt").equals(0).toArray();
				console.log('backgroundPreload.metas:' + metas);
				for (const n of metas) {
					try {
						const q = `'${appFolderId}' in parents and name='${n.id}.json' and trashed=false`;
						// gapi.client.drive.files.list yerine fetch API kullan
						const listResponse = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&spaces=drive&fields=files(id)`, {
							method: "GET",
							headers: {
								"Authorization": `Bearer ${accessToken}`
							}
						});
						
						if (!listResponse.ok) {
							const errorData = await listResponse.json();
							throw new Error(`Dosya listesi hatasƒ±: ${errorData.error?.message || listResponse.statusText}`);
						}
						
						const listData = await listResponse.json();
						if (!listData.files.length) continue;
						
						// gapi.client.drive.files.get yerine fetch API kullan
						const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${listData.files[0].id}?alt=media`, {
							method: "GET",
							headers: {
								"Authorization": `Bearer ${accessToken}`
							}
						});
						
						if (!fileResponse.ok) {
							const errorData = await fileResponse.json();
							throw new Error(`Dosya indirme hatasƒ±: ${errorData.error?.message || fileResponse.statusText}`);
						}
						
						const fileBody = await fileResponse.text();
						await opfsWrite(n.id + ".json", fileBody);
						await db.notes.update(n.id, {
							cachedInt: 1,
							accessedAt: Date.now()
						});
						await checkQuotaAndEvict();
						await new Promise(res => setTimeout(res, 1000));
					} catch (e) {
						log("preload hata " + n.id, "warn");
					}
				}
			}
			
			setInterval(backgroundPreload, 300000);

			// ==========================
			// Quota + LRU
			// ==========================
			async function checkQuotaAndEvict() {
				if (!navigator.storage.estimate) return;
				const est = await navigator.storage.estimate();
				if (est.usage / est.quota < 0.8) return;
				const olds = await db.notes.orderBy("accessedAt").limit(5).toArray();
				for (const n of olds) {
					await opfsDelete(n.id + ".json");
					await db.notes.update(n.id, {
						cachedInt: 0
					});
				}
			}
			
			// ==========================
			// UI
			// ==========================
			async function refreshList() {
				const allRows = await db.notes.orderBy("updatedAt").reverse().toArray();
				const rows = allRows.filter(n => n.isDeleted !== 1);
				const tb = $('#notesTable');
				tb.innerHTML = "";
				for (const n of rows) {
					const status = [n.pendingInt ? "‚è≥ pending" : "", n.cachedInt ? "üíæ cached" : ""].join(" ");
					const tr = document.createElement("tr");
					tr.innerHTML = `
									
						<td>${n.title}</td>
						<td>${n.updatedAt}</td>
						<td>${status}</td>
						<td>
							<button onclick="loadNote('${n.id}')">Y√ºkle</button>
							<button onclick="copyNote('${n.id}')">Kopyala</button>
							<button onclick="showHistory('${n.id}')">Tarih√ße</button>
							<button onclick="deleteNote('${n.id}')">Sil</button>
						</td>`;
					tb.appendChild(tr);
				}
			}
			
			// Sayfa y√ºklendikten sonra gapi'yi ba≈ülat
			window.addEventListener('load', () => {
				setTimeout(initGapi, 1000); // 1 saniye bekle
			});

			$('#saveBtn').onclick = () => {
				const title = $('#title').value;				
				const delta = quill ? quill.getContents() : '';
				const deltaText = quill ? quill.getText().trim() : '';
				saveNote(title, delta, deltaText);
			};
			$('#syncBtn').onclick = SynchronizeGoogleDrive;
			$('#newBtn').onclick = () => {
				currentNoteId = null;
				$('#title').value = "";
				quill.setContents({
					ops: []
				});
			};
			$('#googleConnectBtn').onclick = async () => {
				// Eƒüer zaten baƒülƒ±ysa, baƒülantƒ±yƒ± kes
				if (accessToken) {
					await clearGoogleAuthState();
					accessToken = null;
					userEmail = null;
					appFolderId = null;
					masterKey = null;
					$('#who').textContent = 'Baƒülƒ± deƒüil';
					$('#googleConnectBtn').textContent = 'Google\'a Baƒülan';
					log("üîå Google baƒülantƒ±sƒ± kesildi");
					return;
				}

				try {
					if (typeof google === 'undefined' || !google.accounts) {
						log("‚ùå Google API hen√ºz y√ºklenmedi, l√ºtfen bekleyin", "error");
						return;
					}
					tokenClient = google.accounts.oauth2.initTokenClient({
						client_id: GOOGLE_CLIENT_ID,
						scope: 'https://www.googleapis.com/auth/drive.file',
						callback: async (response) => {
							if (response.error) {
								log("‚ùå OAuth hatasƒ±: " + response.error, "error");
								return;
							}
							accessToken = response.access_token;
							gapi.client.setToken({
								access_token: accessToken
							});
							// Kullanƒ±cƒ± bilgilerini al
							try {
								const userInfo = await gapi.client.oauth2.userinfo.get();
								userEmail = userInfo.result.email;
								$('#who').textContent = `Baƒülƒ±: ${userEmail}`;
								$('#googleConnectBtn').textContent = 'Baƒülantƒ±yƒ± Kes';
								log(`‚úÖ Google Drive'a ba≈üarƒ±yla baƒülandƒ±: ${userEmail}`);
								// Master key'i t√ºret ve sakla
								masterKey = await deriveKey(userEmail, "salt");
								await saveMasterKey(masterKey);
								// Baƒülantƒ± durumunu g√ºvenli storage'a kaydet
								await saveGoogleAuthState(accessToken, userEmail);
							} catch (e) {
								$('#who').textContent = 'Baƒülƒ±';
								$('#googleConnectBtn').textContent = 'Baƒülantƒ±yƒ± Kes';
								log("‚úÖ Google Drive'a ba≈üarƒ±yla baƒülandƒ±");
								// Master key'i t√ºret ve sakla (email yok)
								masterKey = await deriveKey("demo", "salt");
								await saveMasterKey(masterKey);
								// Baƒülantƒ± durumunu g√ºvenli storage'a kaydet
								await saveGoogleAuthState(accessToken, '');
							}
							ensureFolder();
						}
					});
					tokenClient.requestAccessToken();
				} catch (e) {
					log("‚ùå Baƒülanma hatasƒ±: " + e.message, "error");
				}
			};
      
			refreshList();
		</script>
	</body>
</html>